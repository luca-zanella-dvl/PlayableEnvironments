import glob
import os
import re
import shutil
import subprocess
from pathlib import Path
from typing import Tuple, List


class VideoFragmenter:

    @staticmethod
    def get_videos(directory: str, extension="mp4") -> List[str]:
        '''
        Gets all videos in a directory with a certain extension
        :param directory:
        :param extension:
        :return: Sorted list of videos matching a given extension in the directory
        '''

        return list(sorted(glob.glob(os.path.join(directory, f"*.{extension}"))))

    @staticmethod
    def extract_frames(video_path: str, output_directory: str, fps: float, output_size: Tuple[int, int], extension="png") -> List[str]:
        '''

        :param video_path: Path to the video of which to extract frames
        :param output_directory: Directory where to output the video. Will be created if not existing
        :param fps: Framerate at which to extract frames
        :param output_size: (width, height) of the extracted frames
        :return: List with the path to the extracted images
        '''

        # Makes the output directory
        Path(output_directory).mkdir(exist_ok=True, parents=True)

        video_basename = os.path.basename(video_path).split(".")[0]

        # Name for the output frames
        current_output_pattern = os.path.join(output_directory, f'%05d.{extension}')

        output_width, output_height = output_size
        # Command to split the video and render each frame
        command_parameters = ["ffmpeg", "-i", video_path, "-y", "-vf", f"scale={output_width}:{output_height},fps={fps}", current_output_pattern]

        # Splits the video
        subprocess.run(command_parameters, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Patches the file names so that they start from 0
        VideoFragmenter.patch_indexes_filenemes(output_directory, extension)

        # Gets the list of generated images
        generated_images = VideoFragmenter.get_generated_images(output_directory, extension)
        return generated_images

    @staticmethod
    def get_generated_images(directory: str, extension="png") -> List[str]:
        '''

        :param directory: directory where to search the images
        :return: List of mages that were generated by the fragmenter
        '''

        all_images = list(sorted(glob.glob(os.path.join(directory, f"*.{extension}"))))
        generated_images = [current_image for current_image in all_images if VideoFragmenter.is_extracted_image(current_image, extension)]

        return generated_images

    @staticmethod
    def is_extracted_image(image_path: str, extension="png") -> bool:
        '''
        Checks whether an image was generated by the fragmenter
        :param image_path:
        :return: True if the given image was extracted by the video fragmenter
        '''

        basename = os.path.basename(image_path)
        regexp = fr"[0-9][0-9][0-9][0-9][0-9].{extension}$"

        return bool(re.match(regexp, basename))

    @staticmethod
    def clean_frames(directory: str, extension="png"):
        '''
        Deletes all the previously extracted frames from a directory

        :param directory:
        :return:
        '''

        generated_images = VideoFragmenter.get_generated_images(directory, extension)
        for current_image in generated_images:
            if os.path.exists(current_image):
                os.remove(current_image)
            else:
                raise Exception(f"{current_image} should exist but has already been canceled")

    @staticmethod
    def patch_indexes_filenemes(directory: str, extension: str="png"):
        '''
        Shifts all image names from [1, frames_count] to [0, frames_count - 1]

        :param directory: Directory to patch
        :return:
        '''

        all_images = list(sorted(glob.glob(os.path.join(directory, f"*.{extension}"))))
        for idx, current_image in enumerate(all_images):
            if VideoFragmenter.is_extracted_image(current_image, extension):

                original_id = int(os.path.basename(current_image).split(".")[0][-5:])
                substituted_id = original_id - 1

                new_image_name = os.path.join(directory, os.path.basename(current_image).split(".")[0][:-5] + f"{substituted_id:05d}.{extension}")
                shutil.move(current_image, new_image_name)
